# ========== 配置部分 ==========
# 允许用户通过环境变量覆盖默认值

# Python 环境
PYTHON ?= python3
VENV ?= venv

# 核心配置
CONFIG ?= config.yaml
TEMPLATE ?=

# 目录配置
WORKSPACE_DIR ?= repo-workspace
PDF_DIR ?= repo-pdfs
TEMP_DIR ?= temp
TEMPLATE_DIR ?= templates

# 运行参数
VERBOSE ?= 0
QUIET ?= 0

# ========== 自动检测部分 ==========
UNAME_S := $(shell uname -s)
VENV_BIN := $(VENV)/bin
VENV_PYTHON := $(VENV_BIN)/python
VENV_PIP := $(VENV_BIN)/pip

# 检测是否在 WSL2 环境
IS_WSL := $(shell grep -qi microsoft /proc/version 2>/dev/null && echo 1 || echo 0)

# 检查必要的命令
REQUIRED_CMDS := python3 git xelatex pandoc

# 构建转换参数
CONVERT_ARGS := -c $(CONFIG)
ifeq ($(VERBOSE),1)
    CONVERT_ARGS += -v
endif
ifeq ($(QUIET),1)
    CONVERT_ARGS += -q
endif
ifneq ($(TEMPLATE),)
    CONVERT_ARGS += -t $(TEMPLATE)
endif

# ========== 样式定义 ==========
# 支持 NO_COLOR 环境变量禁用颜色
ifndef NO_COLOR
    BLUE := \033[1;34m
    GREEN := \033[0;32m
    RED := \033[0;31m
    YELLOW := \033[1;33m
    NC := \033[0m
else
    BLUE :=
    GREEN :=
    RED :=
    YELLOW :=
    NC :=
endif

# 定义打印函数
define print_status
	echo "$(BLUE)==> $(1)$(NC)"
endef

define print_success
	echo "$(GREEN)✓ $(1)$(NC)"
endef

define print_warning
	echo "$(YELLOW)! $(1)$(NC)"
endef

define print_error
	echo "$(RED)✗ $(1)$(NC)"
endef

# ========== 目标定义 ==========
.PHONY: all deps convert clean clean-all reset help check-reqs install-deps \
        create-venv debug list-templates setup check-config quickstart \
        install-deps-if-needed test test-unit test-integration test-coverage

# 默认目标 - 简单直接
all: convert

# 快捷方式
debug: VERBOSE=1
debug: convert

# 仅安装依赖
setup: deps

# 快速开始 - 为新用户提供引导
quickstart:
	@if [ ! -f $(CONFIG) ]; then \
		@$(call print_status,创建示例配置文件); \
		echo '# 仓库配置\nrepository:\n  url: "https://github.com/用户名/仓库名.git"\n  branch: "main"\n\n# 使用默认设置即可\nworkspace_dir: "./repo-workspace"\noutput_dir: "./repo-pdfs"\n\nignores:\n  - "node_modules"\n  - ".git"' > $(CONFIG); \
		@$(call print_success,已创建 $(CONFIG)); \
		@$(call print_warning,请编辑 $(CONFIG) 中的仓库地址); \
	else \
		@$(call print_success,配置文件已存在: $(CONFIG)); \
	fi
	@$(call print_status,下一步:)
	@echo "  1. 编辑 $(CONFIG) 中的仓库地址"
	@echo "  2. 运行 'make' 开始转换"

# 列出可用模板
list-templates:
	@$(call print_status,可用的模板)
	@if [ -d $(TEMPLATE_DIR) ]; then \
		for template in $(TEMPLATE_DIR)/*.yaml; do \
			if [ -f "$$template" ]; then \
				name=$$(basename $$template .yaml); \
				desc=$$(grep -m1 "description:" $$template 2>/dev/null | sed 's/.*description: *"\(.*\)"/\1/' || echo ""); \
				echo "  $(GREEN)$$name$(NC) - $$desc"; \
			fi \
		done; \
	else \
		@$(call print_warning,模板目录不存在); \
	fi

# ========== 依赖管理 ==========
# 检查必要的命令
check-reqs:
	@$(call print_status,检查必要的命令)
	@missing_cmds=""; \
	for cmd in $(REQUIRED_CMDS); do \
		if ! command -v $$cmd >/dev/null 2>&1; then \
			missing_cmds="$$missing_cmds $$cmd"; \
		fi; \
	done; \
	if [ -n "$$missing_cmds" ]; then \
		@$(call print_error,缺少以下命令:$$missing_cmds); \
		@$(call print_warning,请运行 'make install-deps' 安装系统依赖); \
		exit 1; \
	else \
		@$(call print_success,所有必要的命令都已安装); \
	fi

# 依赖管理主目标
deps: install-deps-if-needed $(VENV)/deps-installed

# 智能检查并安装缺失的依赖
install-deps-if-needed:
	@missing_cmds=""; \
	for cmd in $(REQUIRED_CMDS); do \
		if ! command -v $$cmd >/dev/null 2>&1; then \
			missing_cmds="$$missing_cmds $$cmd"; \
		fi; \
	done; \
	if [ -n "$$missing_cmds" ]; then \
		@$(call print_warning,检测到缺失的命令:$$missing_cmds); \
		@$(call print_status,尝试自动安装...); \
		$(MAKE) install-deps; \
	else \
		@$(call print_success,系统依赖已满足); \
	fi

# 智能系统依赖安装
install-deps:
	@$(call print_status,安装系统依赖)
ifeq ($(UNAME_S),Darwin)
	@# macOS - 使用 Homebrew
	@command -v brew >/dev/null 2>&1 || { \
		@$(call print_warning,安装 Homebrew...); \
		/bin/bash -c "$$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; \
	}
	@# 批量检查和安装
	@for pkg in pandoc cairo; do \
		brew list $$pkg >/dev/null 2>&1 || brew install $$pkg; \
	done
	@command -v inkscape >/dev/null 2>&1 || brew install inkscape
	@command -v xelatex >/dev/null 2>&1 || { \
		@$(call print_warning,安装 MacTeX (这可能需要较长时间)...); \
		brew install --cask mactex-no-gui; \
	}
else ifeq ($(UNAME_S),Linux)
	@# Linux/WSL2 - 自动检测包管理器并安装
	@if [ "$(IS_WSL)" = "1" ]; then \
		@$(call print_status,检测到 WSL2 环境); \
		@$(call print_warning,注意: 建议将项目放在 WSL2 文件系统内以获得更好的性能); \
	fi
	@if command -v apt-get >/dev/null 2>&1; then \
		@$(call print_status,检测到 apt-get，自动安装依赖...); \
		if [ -z "$$GITHUB_ACTIONS" ] && [ -z "$$CI" ]; then \
			@$(call print_warning,需要 sudo 权限安装系统包); \
			@$(call print_status,安装 TeX Live 和字体包 (可能需要几分钟)...); \
			sudo apt-get update && sudo apt-get install -y \
				pandoc texlive-xetex texlive-fonts-recommended \
				texlive-fonts-extra texlive-lang-chinese \
				python3-venv python3-pip libcairo2-dev inkscape \
				fonts-noto-cjk fonts-wqy-microhei || { \
					@$(call print_error,自动安装失败，请手动运行上述命令); \
					exit 1; \
				}; \
			if [ "$(IS_WSL)" = "1" ]; then \
				@$(call print_success,WSL2 依赖安装完成); \
				@$(call print_warning,提示: 如果需要 Windows 字体，可以运行:); \
				echo "  sudo ln -s /mnt/c/Windows/Fonts /usr/share/fonts/windows"; \
				echo "  sudo fc-cache -fv"; \
			fi; \
		else \
			@$(call print_warning,CI 环境检测到，跳过系统包安装); \
		fi; \
	elif command -v yum >/dev/null 2>&1; then \
		@$(call print_warning,检测到 yum，请手动安装:); \
		echo "  sudo yum install -y texlive-xetex pandoc python3-devel cairo-devel inkscape"; \
	elif command -v pacman >/dev/null 2>&1; then \
		@$(call print_warning,检测到 pacman，请手动安装:); \
		echo "  sudo pacman -S texlive-core pandoc python-cairo inkscape"; \
	else \
		@$(call print_warning,未检测到包管理器，请手动安装依赖); \
	fi
else
	@$(call print_error,不支持的操作系统: $(UNAME_S))
endif

# Python 虚拟环境
$(VENV)/deps-installed: requirements.txt
	@$(call print_status,设置 Python 环境)
	@test -d $(VENV) || $(PYTHON) -m venv $(VENV)
	@$(VENV_PIP) install --quiet --upgrade pip
	@$(VENV_PIP) install --quiet -r requirements.txt
	@touch $@
	@$(call print_success,Python 依赖安装完成)

# ========== 核心功能 ==========
# 转换为 PDF
convert: deps
	@$(call print_status,开始转换 PDF)
	@if [ ! -f $(CONFIG) ]; then \
		@$(call print_error,找不到配置文件: $(CONFIG)); \
		@$(call print_warning,请创建 config.yaml 或使用 CONFIG=其他配置.yaml); \
		exit 1; \
	fi
	@$(VENV_PYTHON) repo-to-pdf.py $(CONVERT_ARGS)

# ========== 清理功能 ==========
# 清理临时文件
clean:
	@$(call print_status,清理临时文件)
	@rm -rf $(TEMP_DIR) temp_conversion_files
	@rm -rf $(WORKSPACE_DIR)
	@rm -f debug.md
	@find . -name "*.pyc" -delete 2>/dev/null || true
	@find . -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
	@$(call print_success,清理完成)

# 深度清理
clean-all: clean
	@$(call print_status,清理所有生成文件)
	@rm -rf $(PDF_DIR)
	@rm -rf $(VENV)
	@$(call print_success,全部清理完成)

# 重置项目
reset: clean-all
	@$(call print_warning,项目已重置到初始状态)

# ========== 测试功能 ==========
# 运行所有测试
test: deps
	@$(call print_status,运行所有测试)
	@$(VENV_PYTHON) -m pytest
	@$(call print_success,测试完成)

# 运行单元测试
test-unit: deps
	@$(call print_status,运行单元测试)
	@$(VENV_PYTHON) -m pytest tests/test_repo_to_pdf.py -v
	@$(call print_success,单元测试完成)

# 运行集成测试
test-integration: deps
	@$(call print_status,运行集成测试)
	@$(VENV_PYTHON) -m pytest tests/test_integration.py -v
	@$(call print_success,集成测试完成)

# 生成测试覆盖率报告
test-coverage: deps
	@$(call print_status,生成测试覆盖率报告)
	@$(VENV_PYTHON) -m pytest --cov=repo_to_pdf --cov-report=html --cov-report=term
	@$(call print_success,覆盖率报告已生成: htmlcov/index.html)
	@if command -v open >/dev/null 2>&1; then \
		open htmlcov/index.html; \
	elif command -v xdg-open >/dev/null 2>&1; then \
		xdg-open htmlcov/index.html; \
	fi

# ========== 帮助系统 ==========
help:
	@echo "$(BLUE)GitHub Repo to PDF - 将代码仓库转换为 PDF 文档$(NC)"
	@echo
	@echo "$(YELLOW)快速开始:$(NC)"
	@echo "  $$ make quickstart         # 创建示例配置文件"
	@echo "  $$ make                    # 转换 config.yaml 中配置的仓库"
	@echo "  $$ make TEMPLATE=technical # 使用技术文档模板"
	@echo "  $$ make list-templates     # 查看所有可用模板"
	@echo
	@echo "$(YELLOW)常用命令:$(NC)"
	@echo "  $(GREEN)make$(NC)              转换为 PDF (默认)"
	@echo "  $(GREEN)make debug$(NC)        调试模式 (显示详细日志)"
	@echo "  $(GREEN)make setup$(NC)        仅安装依赖"
	@echo "  $(GREEN)make test$(NC)         运行所有测试"
	@echo "  $(GREEN)make test-coverage$(NC) 生成测试覆盖率报告"
	@echo "  $(GREEN)make clean$(NC)        清理临时文件"
	@echo "  $(GREEN)make clean-all$(NC)    清理所有文件"
	@echo "  $(GREEN)make reset$(NC)        重置到初始状态"
	@echo
	@echo "$(YELLOW)配置选项:$(NC)"
	@echo "  $(GREEN)CONFIG=file$(NC)       指定配置文件 (默认: config.yaml)"
	@echo "  $(GREEN)TEMPLATE=name$(NC)     使用模板 (查看: make list-templates)"
	@echo "  $(GREEN)VERBOSE=1$(NC)         显示详细输出"
	@echo "  $(GREEN)QUIET=1$(NC)           静默模式"
	@echo "  $(GREEN)NO_COLOR=1$(NC)        禁用彩色输出"
	@echo
	@echo "$(YELLOW)示例:$(NC)"
	@echo "  $$ make CONFIG=myrepo.yaml"
	@echo "  $$ make TEMPLATE=technical VERBOSE=1"
	@echo "  $$ CONFIG=test.yaml TEMPLATE=default make debug"

# 添加一个配置检查目标
check-config:
	@echo "$(BLUE)当前配置:$(NC)"
	@echo "  配置文件: $(CONFIG)"
	@echo "  模板: $(if $(TEMPLATE),$(TEMPLATE),无)"
	@echo "  Python: $(PYTHON)"
	@echo "  虚拟环境: $(VENV)"
	@echo "  输出目录: $(PDF_DIR)"
	@echo "  操作系统: $(UNAME_S)$(if $(filter 1,$(IS_WSL)), (WSL2),)"
	@if [ "$(IS_WSL)" = "1" ]; then \
		echo "  $(YELLOW)WSL2 提示: 确保项目在 Linux 文件系统中$(NC)"; \
	fi 